---
layout: post
title: <DB> 인덱스(index) 란 ? - 이론편
categories: DB
tags: [DB, index]
---

### [DB] 인덱스(index) 란 ? - 이론편 

### 개념 

> **인덱스**([영어](https://ko.wikipedia.org/wiki/영어): index)는 [데이터베이스](https://ko.wikipedia.org/wiki/데이터베이스) 분야에 있어서 [테이블](https://ko.wikipedia.org/wiki/테이블_(데이터베이스))에 대한 동작의 속도를 높여주는 [자료 구조](https://ko.wikipedia.org/wiki/자료_구조)를 일컫는다. 인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성될 수 있다. 고속의 검색 동작뿐만 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공한다. 인덱스를 저장하는 데 필요한 디스크 공간은 보통 테이블을 저장하는 데 필요한 디스크 공간보다 작다. (왜냐하면 보통 인덱스는 키-필드만 갖고 있고, 테이블의 다른 세부 항목들은 갖고 있지 않기 때문이다.) [관계형 데이터베이스](https://ko.wikipedia.org/wiki/관계형_데이터베이스)에서는 인덱스는 테이블 부분에 대한 하나의 사본이다. 인덱스는 고유 제약 조건을 실현하기 위해서도 사용된다. 고유 인덱스는 중복된 항목이 등록되는 것을 금지하기 때문에 인덱스의 대상인 테이블에서 고유성이 보장된다. - 위키백과

- INDEX = 색인 <br>
EX) 만쪽이 넘는 책에서 내가 원하는 부분을 찾을려고 할 때 한장한장 넘겨가면서 찾으면 백만년 걸림 <br>
=> 색인이나 목차 **한번에** 찾을 수 있음 

- DB 의 인덱스도 DB 에 대한 색인이나 목차라고 생각하면 된다. 없는 경우 테이블의 **처음부터 끝(table full scan)**까지 모두 뒤져야 하지만 인덱스가 걸려 있다면 더욱 빠르게 찾을 수 있다 

- 인덱스로 들어온 칼럼값들은 값을 정렬하여 순차적으로 저장됨 <br>
=> 새로운 데이터 값이 들어오는 경우 이를 순차적으로 찾아 정리하기 때문에 새로운 데이터를 insert, delete 하는 것은 시간이 오래 걸리지만 search 는 빨리 됨 

  

### clustered vs secondary INDEX
#### Clustered Index 

> 페이지를 알고 있어서 해당 페이지를 바로 펼침 

- 테이블 당 **하나만** 생성 가능 <br>
=> MySQL 에선 Primary Key 가 있는 경우 Primary Key , 없으면 UNIQUE 하면서 NOT NULL 인 컬럼 , 그것도 없다면 임의로 보이지 않는 컬럼을 만들어서 Clustered Index 로 지정 
- 생성 시에는 데이터 페이지 전체가 다시 정렬 
- 영어 사전처럼 책의 내용 자체가 순서대로 정렬되어 있어 인덱스 자체가 책의 내용과 같음 
- 보조 인덱스 보다 검색 속도는 더 빠르다. 하지만 입력/수정/삭제는 더 느리다.
- 데이터 검색 순서 : `루트페이지 -> 리프 페이지(=데이터 페이지)`
- 리프 페이지가 꽉차 있는 경우 **페이지 분할 발생** <br>
=> select 성능은 좋지만 insert, update, delete 성능은 떨어짐 
- 리프 노드에서 데이터까지 가지고 있고 물리적으로 데이터를 **재배열**
![https://media.vlpt.us/images/gillog/post/5e179f0b-2100-4b82-9260-f2870c5d811a/2716FA44512C6B9827.png](https://media.vlpt.us/images/gillog/post/5e179f0b-2100-4b82-9260-f2870c5d811a/2716FA44512C6B9827.png)


#### Secondary Index (Non Clustered Index)
> 목차에서 찾고자 하는 내용의 페이지를 찾고 나서 해당 페이지로 이동

- 테이블 당 **여러개** 생성 가능 
- 보조 인덱스의 생성시에는 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구성.
- 보조 인덱스의 인덱스 자체의 리프 페이지는 데이터가 아니라 데이터가 위치하는 주소값(RID)
- 클러스터형 보다 검색 속도는 더 느리지만 데이터의 입력/수정/삭제는 덜 느리다.
- 보조 인덱스는 여러 개 생성할 수 있다. 함부로 사용할 경우에는 오히려 성능을 떨어뜨릴 수 있다 
- 데이터 검색 순서 : `루트페이지 -> 리프 페이지 -> 데이터 페이지`
- 리프 페이지가 모두 차있어도 **페이지 분할이 발생하지 않음** <br>
  => insert, update, delete 성능은 좋지만 select 성능은 떨어짐 
- 리프 노드에서 데이터 주소를 가지고 있고 물리적으로 데이터를 **재배열하지 않음**
![https://media.vlpt.us/images/gillog/post/f8b57040-6173-40dd-9860-8b09c4ac3723/1123E744512C6B9914.png](https://media.vlpt.us/images/gillog/post/f8b57040-6173-40dd-9860-8b09c4ac3723/1123E744512C6B9914.png)


### 인덱스의 종류 
#### B(Balanced)-tree Index
- 가장 보편적으로 사용되는 인덱스 
- 노드 하나에 여러 데이터가 저장될 수 있다 
- 각 노드내 데이터들은 항상 정렬된 상태이며, 데이터와 데이터 사이의 범위를 이용해서 자식 노드를 가진다 
- 항상 좌, 우 자식 노드 개수의 밸런스를 유지하기 때문에 최악의 경우에도 탐색 시간이 ` O(logN)`
- 등호 (=) 나 부등호 (<, >) 를 사용하기에도 적합하다 
- 각 노드는 최대 2개의 key, 최대 3개의 child 를 가질 수 있다 

![https://user-images.githubusercontent.com/39696812/124501489-9e2a4700-ddfc-11eb-8627-d9a2ac9a7777.png](https://user-images.githubusercontent.com/39696812/124501489-9e2a4700-ddfc-11eb-8627-d9a2ac9a7777.png)



#### B+Tree Index

- 자식 노드가 2개 이상인 B-Tree 를 개선시킨 자료구조 
- 리프노드만 인덱스와 데이터를 가지고 있고 나머지 노드들은 데이터를 위한 인덱스만 가지고 있음 
- 리프 노드들은 LinkedList 로 연결 


#### Bitmap Index
- 컴퓨터에서 사용하는 최소단위인 비트를 이용하여 컬럼값을 저장하고, ROWID를 자동으로 생성하는 인덱스의 한 방법


#### IOT Index
- Random 액세스가 발생하지 않도록 테이블을 아예 인덱스 구조로 생성되어 있는 Table
- 테이블을 찾아가기 위한 rowid를 갖는 일반 인덱스와는 달리 IOT는 모든 행 데이터를 리프블록에 저장


### 인덱스 장점 vs 단점 
#### 장점 
- 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다.
- 전반적인 시스템의 부하를 줄일 수 있다.

#### 단점 
- 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간이 필요하다.
- 인덱스를 관리하기 위해 추가 작업이 필요하다.
- 인덱스를 잘못 사용할 경우 오히려 성능이 저하되는 역효과가 발생할 수 있다.<br>
  => INSERT, UPDATE, DELETE 등의 액션이 발생했을 때 인덱스를 최신의 정렬된 상태로 유지하기 위해서 추가적인 연산 필요 

### 인덱스 사용 이유 
- WHERE 구문과 일치하는 열을 **빨리 찾기 위해.**
- 특정 열을 고려 대상에서 **빨리 없애 버리기 위해.**
- **조인 (join)을 실행**할 때 **다른 테이블에서 열을 추출하기 위해.**
- **특정하게 인덱스된 컬럼**을 위한 **MIN() 또는 MAX() 값을 찾기 위해.**
- 사용할 수 있는 키의 최 좌측 접두사(leftmost prefix)를 가지고 **정렬 및 그룹화를 하기 위해.**
- 데이터 열을 참조하지 않는 상태로 값을 추출하기 위해서 **쿼리를 최적화 하는 경우.**

### 인덱스 작동 원리 

```sql
select *
from users
where user_id = 55555
```
- 저장된 user 가 10만명일 때 위 SQL 을 실행할 경우 
  1. 서버 프로세스가 파싱 과정을 마친 후 **`DB buffer cache`에 user_id 가 55555인 정보가 있는지 확인**한다.
  2. 정보가 없으면 **`하드 디스크 파일`에서 55555 정보를 가진 블록을 복사**해서 `DB buffer cache`로 가져온 후 **55555 정보만 골라내서 사용자에게 보여줌**

- **Index 없는 경우** : 55555정보가 어떤 블록에 들어 있는지 모르므로 **10만개 전부 `db buffer cache`로 복사한 후 하나하나 찾는다.**
- **Index 있는 경우** : **where 절의 컬럼이 index가 만들어져 있는지 확인** 후, **인덱스에 먼저 가서 55555정보가 어떤 `ROWID`를 가지고 있는지 확인**한 후 **해당 `ROWID`에 있는 블록만 찾아가서 `db buffer cache`에 복사**함.

### 레퍼런스

[[데이터베이스] B-Tree 인덱스 구조](https://beelee.tistory.com/37)<br>
[[Database] DB 인덱싱(Indexing)이란?](https://velog.io/@bsjp400/Database-DB-%EC%9D%B8%EB%8D%B1%EC%8B%B1Indexing%EC%9D%B4%EB%9E%80)<br>
[[SQL] Index(인덱스)](https://velog.io/@gillog/SQL-Index%EC%9D%B8%EB%8D%B1%EC%8A%A4)<br>
[[SQL] Clustered Index & Non-Clustered Index](https://velog.io/@gillog/SQL-Clustered-Index-Non-Clustered-Index)<br>
